<#@ template language="C#" #>
using JetBrains.Annotations;
using System;
using System.Collections.Generic;

namespace JotunShard.Extensions
{
    public static class Delegates
    {<#
var typePrefix = "TArg";
var argPrefix = "arg";
var paramPrefix = "param";
var maxArgs = 16;
var maxTuple = 7;
var itemSep = ", ";

var globalTypesLine = string.Empty;
var globalValuesLine = string.Empty;
var resultTypeLine = string.Empty;
var paramLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    var typesLine = globalTypesLine;
    var summaryArgsLine = string.Empty;
    var commentArgsLine = string.Empty;
    var argsLine = string.Empty;
    var valuesLine = globalValuesLine;
    for (var innerIndex = index; innerIndex <= maxArgs; ++innerIndex)
    {
        typesLine += typePrefix + innerIndex + itemSep;
        summaryArgsLine += itemSep + innerIndex;
        commentArgsLine += itemSep + argPrefix + innerIndex;
        argsLine += itemSep + typePrefix + innerIndex + " " + argPrefix + innerIndex;
        valuesLine += itemSep + argPrefix + innerIndex;
#>

        /// <summary>
        /// Redefinition of a function of <#=innerIndex#> parameters with its arguments <#=summaryArgsLine.Substring(2)#> binded
        /// </summary>
<#
        for (var commentIndex = 1; commentIndex <= innerIndex; ++commentIndex)
        {
#>
        /// <typeparam name="TArg<#=commentIndex#>">The type of argument <#=commentIndex#></typeparam>
<#
        }
#>
        /// <typeparam name="TResult">Resultant type of the function</typeparam>
        /// <param name="func">The targeted function</param>
<#
        for (var commentIndex = 1; commentIndex <= innerIndex; ++commentIndex)
        {
#>
        /// <param name="arg<#=commentIndex#>">The provided value for the argument <#=commentIndex#></param>
<#
        }
#>
        /// <returns>Function with the binded values of <#=commentArgsLine.Substring(2)#></returns>
        public static Func<<#=resultTypeLine#>TResult> Bind<<#=typesLine#>TResult>(
            [NotNull] this Func<<#=typesLine#>TResult> func<#=argsLine#>)
        {
            func.CheckArgumentNull(nameof(func));
            return (<#=paramLine.Substring(System.Math.Min(2, paramLine.Length))#>) => func(<#=valuesLine.Substring(2)#>);
        }
<#
    }
    globalTypesLine += typePrefix + index + itemSep;
    globalValuesLine += itemSep + argPrefix + index;
    resultTypeLine += typePrefix + index + itemSep;
    paramLine += itemSep + argPrefix + index;
}
globalTypesLine = string.Empty;
globalValuesLine = string.Empty;
resultTypeLine = string.Empty;
paramLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    var typesLine = globalTypesLine;
    var summaryArgsLine = string.Empty;
    var commentArgsLine = string.Empty;
    var argsLine = string.Empty;
    var valuesLine = globalValuesLine;
    for (var innerIndex = index; innerIndex <= maxArgs; ++innerIndex)
    {
        typesLine += itemSep + typePrefix + innerIndex;
        summaryArgsLine += itemSep + innerIndex;
        commentArgsLine += itemSep + argPrefix + innerIndex;
        argsLine += itemSep + typePrefix + innerIndex + " " + argPrefix + innerIndex;
        valuesLine += itemSep + argPrefix + innerIndex;
#>

        /// <summary>
        /// Redefinition of an action of <#=innerIndex#> parameters with its arguments <#=summaryArgsLine.Substring(2)#> binded
        /// </summary>
<#
        for (var commentIndex = 1; commentIndex <= innerIndex; ++commentIndex)
        {
#>
        /// <typeparam name="TArg<#=commentIndex#>">The type of argument <#=commentIndex#></typeparam>
<#
        }
#>
        /// <param name="act">The targeted action</param>
<#
        for (var commentIndex = 1; commentIndex <= innerIndex; ++commentIndex)
        {
#>
        /// <param name="arg<#=commentIndex#>">The provided value for the argument <#=commentIndex#></param>
<#
        }
#>
        public static Action<#=resultTypeLine.Length == 0 ? "" : "<" + resultTypeLine.Substring(2) + ">"#> Bind<<#=typesLine.Substring(2)#>>(
            [NotNull] this Action<<#=typesLine.Substring(2)#>> act<#=argsLine#>)
        {
            act.CheckArgumentNull(nameof(act));
            return (<#=paramLine.Substring(System.Math.Min(2, paramLine.Length))#>) => act(<#=valuesLine.Substring(2)#>);
        }
<#
    }
    globalTypesLine += itemSep + typePrefix + index;
    globalValuesLine += itemSep + argPrefix + index;
    resultTypeLine += itemSep + typePrefix + index;
    paramLine += itemSep + argPrefix + index;
}
globalTypesLine = typePrefix + 1;
paramLine = argPrefix + 1;
#>

        public static Func<<#=globalTypesLine#>, <#=globalTypesLine#>> Chain<<#=globalTypesLine#>>(
            [NotNull] this Action<<#=globalTypesLine#>> act)
        {
            act.CheckArgumentNull(nameof(act));
            return <#=paramLine#> =>
            {
                act(<#=paramLine#>);
                return <#=paramLine#>;
            };
        }
<#
globalValuesLine = "value.Item1";
for (var index = 2; index <= maxTuple; ++index)
{
    globalTypesLine += itemSep + typePrefix + index;
    globalValuesLine += itemSep + "value.Item" + index;
    paramLine += itemSep + argPrefix + index;
#>

        public static Func<<#=globalTypesLine#>, Tuple<<#=globalTypesLine#>>> Chain<<#=globalTypesLine#>>(
            [NotNull] this Action<<#=globalTypesLine#>> act)
        {
            act.CheckArgumentNull(nameof(act));
            return (<#=paramLine#>) =>
            {
                act(<#=paramLine#>);
                return Tuple.Create(<#=paramLine#>);
            };
        }
<#
}
resultTypeLine = typePrefix + 1 + itemSep;
globalTypesLine = itemSep + typePrefix + 1;
#>

        public static IEnumerable<<#=globalTypesLine.Substring(2)#>> ToGenerator<<#=globalTypesLine.Substring(2)#>>(
            [NotNull] this Func<<#=resultTypeLine#><#=globalTypesLine.Substring(2)#>> func,
            <#=globalTypesLine.Substring(2)#> seed = default(<#=globalTypesLine.Substring(2)#>))
        {
            func.CheckArgumentNull(nameof(func));
            for (var value = func(seed); ;
                value = func(value))
                yield return value;
        }
<#
globalValuesLine = "value.Item1";
paramLine = "seed.Item1";
for (var index = 2; index <= maxTuple; ++index)
{
    resultTypeLine += typePrefix + index + itemSep;
    globalTypesLine += itemSep + typePrefix + index;
    globalValuesLine += itemSep + "value.Item" + index;
    paramLine += itemSep + "seed.Item" + index;
#>

        public static IEnumerable<Tuple<<#=globalTypesLine.Substring(2)#>>> ToGenerator<<#=globalTypesLine.Substring(2)#>>(
            [NotNull] this Func<<#=resultTypeLine#>Tuple<<#=globalTypesLine.Substring(2)#>>> func,
            Tuple<<#=globalTypesLine.Substring(2)#>> seed)
        {
            func.CheckArgumentNull(nameof(func));
            for (var value = func(<#=paramLine#>); ;
                value = func(<#=globalValuesLine#>))
                yield return value;
        }
<#
}
resultTypeLine += typePrefix + (maxTuple + 1) + itemSep;
globalTypesLine += itemSep + typePrefix + (maxTuple + 1);
globalValuesLine += itemSep + "value.Rest";
paramLine += itemSep + "seed.Rest";
#>

        public static IEnumerable<Tuple<<#=globalTypesLine.Substring(2)#>>> ToGenerator<<#=globalTypesLine.Substring(2)#>>(
            [NotNull] this Func<<#=resultTypeLine#>Tuple<<#=globalTypesLine.Substring(2)#>>> func,
            Tuple<<#=globalTypesLine.Substring(2)#>> seed)
        {
            func.CheckArgumentNull(nameof(func));
            for (var value = func(<#=paramLine#>); ;
                value = func(<#=globalValuesLine#>))
                yield return value;
        }
<#
resultTypeLine = typePrefix + 1 + itemSep;
globalTypesLine = itemSep + typePrefix + 1;
paramLine = "default(" + typePrefix + 1 + ")";
for (var index = 2; index <= maxTuple; ++index)
{
    resultTypeLine += typePrefix + index + itemSep;
    globalTypesLine += itemSep + typePrefix + index;
    paramLine += itemSep + "default(" + typePrefix + index + ")";
#>

        public static IEnumerable<Tuple<<#=globalTypesLine.Substring(2)#>>> ToGenerator<<#=globalTypesLine.Substring(2)#>>(
            [NotNull] this Func<<#=resultTypeLine#>Tuple<<#=globalTypesLine.Substring(2)#>>> func)
            => func.ToGenerator(Tuple.Create(<#=paramLine#>));
<#
}
resultTypeLine += typePrefix + (maxTuple + 1) + itemSep;
globalTypesLine += itemSep + typePrefix + (maxTuple + 1);
paramLine += itemSep + "default(" + typePrefix + (maxTuple + 1) + ")";
#>

        public static IEnumerable<Tuple<<#=globalTypesLine.Substring(2)#>>> ToGenerator<<#=globalTypesLine.Substring(2)#>>(
            [NotNull] this Func<<#=resultTypeLine#>Tuple<<#=globalTypesLine.Substring(2)#>>> func)
            => func.ToGenerator(new Tuple<<#=globalTypesLine.Substring(2)#>>(<#=paramLine#>));
<#
globalTypesLine = string.Empty;
resultTypeLine = string.Empty;
globalValuesLine = string.Empty;
var bounceArgsLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    globalTypesLine += typePrefix + index + itemSep;
    resultTypeLine += typePrefix + index + itemSep;
    globalValuesLine += itemSep + paramPrefix + index;
    bounceArgsLine += itemSep + typePrefix + index + " " + paramPrefix + index;
#>

        public struct Bounce<<#=globalTypesLine#>TResult>
        {<#
    for (var innerIndex = 1; innerIndex <= index; ++innerIndex)
    {
#>

            public <#=typePrefix + innerIndex#> Param<#=innerIndex#> { get; }
<#
    }
#>

            public bool HasResult { get; }

            public TResult Result { get; }

            internal Bounce(<#=bounceArgsLine.Substring(2)#>) : this()
            {
<#
    for (var innerIndex = 1; innerIndex <= index; ++innerIndex)
    {
#>
                Param<#=innerIndex#> = <#=paramPrefix + innerIndex#>;
<#
    }
#>
                HasResult = false;
            }

            internal Bounce(TResult result) : this()
            {
                Result = result;
                HasResult = true;
            }
        }
<#
}
#>

        public static class Trampoline
        {<#
globalTypesLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    globalTypesLine += typePrefix + index + itemSep;
#>

            public static Bounce<<#=globalTypesLine#>TResult> ReturnResult<<#=globalTypesLine#>TResult>(TResult result)
                => new Bounce<<#=globalTypesLine#>TResult>(result);
<#
}
globalTypesLine = string.Empty;
var recurseArgsLine = string.Empty;
globalValuesLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    globalTypesLine += typePrefix + index + itemSep;
    recurseArgsLine += itemSep + typePrefix + index + " " + argPrefix + index;
    globalValuesLine += itemSep + argPrefix + index;
#>

            public static Bounce<<#=globalTypesLine#>TResult> Recurse<<#=globalTypesLine#>TResult>(<#=recurseArgsLine.Substring(2)#>)
                => new Bounce<<#=globalTypesLine#>TResult>(<#=globalValuesLine.Substring(2)#>);
<#
}
#>
        }
<#
globalTypesLine = string.Empty;
resultTypeLine = string.Empty;
globalValuesLine = string.Empty;
paramLine = string.Empty;
for (var index = 1; index <= maxArgs; ++index)
{
    globalTypesLine += typePrefix + index + itemSep;
    resultTypeLine += typePrefix + index + itemSep;
    globalValuesLine += itemSep + argPrefix + index;
    paramLine += itemSep + "value.Param" + index;
#>

        public static Func<<#=resultTypeLine#>TResult> ToTrampoline<<#=globalTypesLine#>TResult>(
            [NotNull] this Func<<#=globalTypesLine#>Bounce<<#=globalTypesLine#>TResult>> func)
        {
            func.CheckArgumentNull(nameof(func));
            return (<#=globalValuesLine.Substring(2)#>) =>
            {
                for (var value = func(<#=globalValuesLine.Substring(2)#>); ;
                    value = func(<#=paramLine.Substring(2)#>))
                    if (value.HasResult)
                        return value.Result;
            };
        }
<#
}
#>
    }
}